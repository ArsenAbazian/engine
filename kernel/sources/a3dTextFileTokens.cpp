#include "a3dTextFileTokens.h"

shString a3dTextFileTokens::a3dSceneString = TEXT( "a3dScene" );
shString a3dTextFileTokens::a3dSelectionString = TEXT( "a3dSelection" );
shString a3dTextFileTokens::a3dNodeString = TEXT( "a3dNode" );
shString a3dTextFileTokens::a3dNameString = TEXT( "name" );
shString a3dTextFileTokens::a3dUndefinedString = TEXT( "undefined" );
shString a3dTextFileTokens::a3dcolorString = TEXT( "color" );
shString a3dTextFileTokens::a3dMatrix3String = TEXT( "matrix3" );
shString a3dTextFileTokens::a3dQuatString = TEXT( "quat" );
shString a3dTextFileTokens::a3dFilenameString = TEXT( "filename" );
shString a3dTextFileTokens::a3dEndString = TEXT( "end" );
shString a3dTextFileTokens::a3dTrueString = TEXT( "true" );
shString a3dTextFileTokens::a3dFalseString = TEXT( "false" );
shString a3dTextFileTokens::a3dBitMapString = TEXT( "BitMap" );
shString a3dTextFileTokens::a3dStandardMaterialString = TEXT( "Standardmaterial" );

shString a3dTextFileTokens::a3dStringString = TEXT( "String" );
shString a3dTextFileTokens::a3dIntegerString = TEXT( "Integer" );
shString a3dTextFileTokens::a3dBooleanClassString = TEXT( "BooleanClass" );
shString a3dTextFileTokens::a3dFloatString = TEXT( "Float" );
shString a3dTextFileTokens::a3dColorString = TEXT( "Color" );

shString a3dTextFileTokens::a3dEditableMeshString = TEXT( "Editable_mesh" );
shString a3dTextFileTokens::a3dMeshVertexCountString = TEXT( "vertexCount" );
shString a3dTextFileTokens::a3dMeshFacesCountString = TEXT( "facesCount" );
shString a3dTextFileTokens::a3dMeshVertexFVFString = TEXT( "vertexFVF" ); 
shString a3dTextFileTokens::a3dMeshMapChannelsCountString = TEXT( "mapChannelCount" );
shString a3dTextFileTokens::a3dMeshTransformString = TEXT( "transform" );
shString a3dTextFileTokens::a3dMeshPivotString = TEXT( "pivot" );
shString a3dTextFileTokens::a3dMeshPositionOffsetString = TEXT( "objectOffsetPos" );
shString a3dTextFileTokens::a3dMeshRotationOffsetString = TEXT( "objectOffsetRot" );
shString a3dTextFileTokens::a3dMeshScaleOffsetString = TEXT( "objectOffsetScale" );
shString a3dTextFileTokens::a3dMeshOffsetTransformString = TEXT( "objectTransform" );
shString a3dTextFileTokens::a3dMeshMaterialNameString = TEXT( "materialName" );
shString a3dTextFileTokens::a3dMeshMap1ChannelVertCountString = TEXT( "map1ChannelVertCount" );
shString a3dTextFileTokens::a3dMeshMap2ChannelVertCountString = TEXT( "map2ChannelVertCount" );
shString a3dTextFileTokens::a3dMeshMap3ChannelVertCountString = TEXT( "map3ChannelVertCount" );
shString a3dTextFileTokens::a3dMeshMap4ChannelVertCountString = TEXT( "map4ChannelVertCount" );
shString a3dTextFileTokens::a3dMeshMap5ChannelVertCountString = TEXT( "map5ChannelVertCount" );
shString a3dTextFileTokens::a3dMeshMap6ChannelVertCountString = TEXT( "map6ChannelVertCount" );
shString a3dTextFileTokens::a3dMeshMap7ChannelVertCountString = TEXT( "map7ChannelVertCount" );
shString a3dTextFileTokens::a3dMeshMap8ChannelVertCountString = TEXT( "map8ChannelVertCount" );
shString a3dTextFileTokens::a3dMeshVertexListString = TEXT( "vertexList" );
shString a3dTextFileTokens::a3dMeshFacesListString = TEXT( "faceList" );
shString a3dTextFileTokens::a3dMeshFaceMatIdListString = TEXT( "faceMatIDList" );
shString a3dTextFileTokens::a3dMeshMap1VertexListString = TEXT( "map1VertexList" );
shString a3dTextFileTokens::a3dMeshMap2VertexListString = TEXT( "map2VertexList" );
shString a3dTextFileTokens::a3dMeshMap3VertexListString = TEXT( "map3VertexList" );
shString a3dTextFileTokens::a3dMeshMap4VertexListString = TEXT( "map4VertexList" );
shString a3dTextFileTokens::a3dMeshMap5VertexListString = TEXT( "map5VertexList" );
shString a3dTextFileTokens::a3dMeshMap6VertexListString = TEXT( "map6VertexList" );
shString a3dTextFileTokens::a3dMeshMap7VertexListString = TEXT( "map7VertexList" );
shString a3dTextFileTokens::a3dMeshMap8VertexListString = TEXT( "map8VertexList" );

shString a3dTextFileTokens::a3dMeshMap1FaceListString = TEXT( "map1FaceList" );
shString a3dTextFileTokens::a3dMeshMap2FaceListString = TEXT( "map2FaceList" );
shString a3dTextFileTokens::a3dMeshMap3FaceListString = TEXT( "map3FaceList" );
shString a3dTextFileTokens::a3dMeshMap4FaceListString = TEXT( "map4FaceList" );
shString a3dTextFileTokens::a3dMeshMap5FaceListString = TEXT( "map5FaceList" );
shString a3dTextFileTokens::a3dMeshMap6FaceListString = TEXT( "map6FaceList" );
shString a3dTextFileTokens::a3dMeshMap7FaceListString = TEXT( "map7FaceList" );
shString a3dTextFileTokens::a3dMeshMap8FaceListString = TEXT( "map8FaceList" );

shString a3dTextFileTokens::a3dMaterialString = TEXT( "a3dMaterial" );
shString a3dTextFileTokens::a3dMaterialCountString = TEXT( "materialCount" );
shString a3dTextFileTokens::a3dMaterialStandardString = TEXT( "StandardMaterial" );
shString a3dTextFileTokens::a3dMaterialShaderTypeString = TEXT( "shaderType" );
shString a3dTextFileTokens::a3dMaterialShaderNameString = TEXT( "shaderName" );
shString a3dTextFileTokens::a3dMaterialWireString = TEXT( "wire" );
shString a3dTextFileTokens::a3dMaterialTwoSidedString = TEXT( "twoSided" );
shString a3dTextFileTokens::a3dMaterialFacetedString = TEXT( "faceted" );
shString a3dTextFileTokens::a3dMaterialOpacityString = TEXT( "opacity" );
shString a3dTextFileTokens::a3dMaterialAmbientString = TEXT( "ambient" );
shString a3dTextFileTokens::a3dMaterialDiffuseString = TEXT( "diffuse" );
shString a3dTextFileTokens::a3dMaterialSpecularString = TEXT( "specular" );
shString a3dTextFileTokens::a3dMaterialSelfIllumString = TEXT( "selfIllum" );
shString a3dTextFileTokens::a3dMaterialSpecularLevelString = TEXT( "specularLevel" );
shString a3dTextFileTokens::a3dMaterialGlossinessString = TEXT( "glossiness" );
shString a3dTextFileTokens::a3dMaterialSoftenString = TEXT( "soften" );

shString a3dTextFileTokens::a3dMaterialMapEnablesListString = TEXT( "mapEnablesList" );
shString a3dTextFileTokens::a3dMaterialMapAmountsListString = TEXT( "mapAmountsList" );

shString a3dTextFileTokens::a3dMaterialMapAmbientString = TEXT( "Ambient" );
shString a3dTextFileTokens::a3dMaterialMapDiffuseString = TEXT( "Diffuse" );
shString a3dTextFileTokens::a3dMaterialMapSpecularString = TEXT( "Specular" );
shString a3dTextFileTokens::a3dMaterialMapSpecularLevelString = TEXT( "SpecularLevel" );
shString a3dTextFileTokens::a3dMaterialMapGlossinessString = TEXT( "Glossiness" );
shString a3dTextFileTokens::a3dMaterialMapSelfIlluminationString = TEXT( "SelfIllumination" );
shString a3dTextFileTokens::a3dMaterialMapOpacityString = TEXT( "Opacity" );
shString a3dTextFileTokens::a3dMaterialMapFilterColorString = TEXT( "FilterColor" );
shString a3dTextFileTokens::a3dMaterialMapBumpString = TEXT( "Bump" );
shString a3dTextFileTokens::a3dMaterialMapReflectionString = TEXT( "Reflection" );
shString a3dTextFileTokens::a3dMaterialMapRefractionString = TEXT( "Refraction" );
shString a3dTextFileTokens::a3dMaterialMapDisplacementString = TEXT( "Displacement" );	

shString a3dTextFileTokens::a3dMapClipUString = TEXT( "clipu" );
shString a3dTextFileTokens::a3dMapClipVString = TEXT( "clipv" );
shString a3dTextFileTokens::a3dMapClipWString = TEXT( "clipw" );
shString a3dTextFileTokens::a3dMapClipHString = TEXT( "cliph" );
shString a3dTextFileTokens::a3dMapUMirrorString = TEXT( "umirror" );
shString a3dTextFileTokens::a3dMapVMirrorString = TEXT( "vmirror" );
shString a3dTextFileTokens::a3dMapUTileString = TEXT( "utile" );
shString a3dTextFileTokens::a3dMapVTileString = TEXT( "vtile" );
shString a3dTextFileTokens::a3dMapUVWTypeString = TEXT( "uvwType" );
shString a3dTextFileTokens::a3dMapChannelString = TEXT( "mapChannel" );
shString a3dTextFileTokens::a3dMapUOffsetString = TEXT( "uOffset" );
shString a3dTextFileTokens::a3dMapVOffsetString = TEXT( "vOffset" );
shString a3dTextFileTokens::a3dMapUTilingString = TEXT( "uTiling" );
shString a3dTextFileTokens::a3dMapVTilingString = TEXT( "vTiling" );

shString a3dTextFileTokens::a3dMultiMaterialString = TEXT( "MultiMaterial" );
shString a3dTextFileTokens::a3dMMSubMtlCountString = TEXT( "subMtlCount" );

shString a3dTextFileTokens::a3dMMTypeListString = TEXT( "materialTypeList" );
shString a3dTextFileTokens::a3dMMEnabledListString = TEXT( "mapEnabledList" );
shString a3dTextFileTokens::a3dMMNameListString = TEXT( "materialNameList" );
shString a3dTextFileTokens::a3dMMIdListString = TEXT( "materialIdList" );

shString a3dTextFileTokens::a3dSubMaterialCountString = TEXT( "subMaterialCount" );

shString a3dTextFileTokens::a3dDirectX_9_ShaderString = TEXT( "DirectX_9_Shader" );
shString a3dTextFileTokens::a3dDXEffectFileString = TEXT( "effectFile" );
shString a3dTextFileTokens::a3dDXTechniqueString = TEXT( "technique" );

shString a3dTextFileTokens::a3dLightString = TEXT( "a3dLight" );
shString a3dTextFileTokens::a3dOmnilightString = TEXT( "Omnilight" );
shString a3dTextFileTokens::a3dPositionString = TEXT( "position" );
shString a3dTextFileTokens::a3dFarAttenStartString = TEXT( "farAttenStart" );
shString a3dTextFileTokens::a3dFarAttenEndString = TEXT( "farAttenEnd" );
shString a3dTextFileTokens::a3dDirectionallightString = TEXT( "Directionallight" );
shString a3dTextFileTokens::a3dDirectionString = TEXT( "direction" );

shString a3dTextFileTokens::a3dModelString = TEXT( "a3dModel" );
shString a3dTextFileTokens::a3dfileNameString = TEXT( "fileName" );
shString a3dTextFileTokens::a3deffectFileNameString = TEXT( "effectFileName" );
shString a3dTextFileTokens::a3dParticleSystemString = TEXT( "a3dParticleSystem" );

shString a3dTextFileTokens::a3drailFileNameString = TEXT( "railFileName" );
shString a3dTextFileTokens::a3dlineModelFileNameString = TEXT ( "lineModelFileName" );
shString a3dTextFileTokens::a3droundModelFileNameString = TEXT ( "roundModelFileName" );
shString a3dTextFileTokens::a3dlineEffectFileNameString = TEXT ( "lineEffectFileName" );
shString a3dTextFileTokens::a3droundEffectFileNameString = TEXT ( "roundEffectFileName" );
shString a3dTextFileTokens::a3dround2EffectFileNameString = TEXT ( "round2EffectFileName" );
shString a3dTextFileTokens::a3dlandNameString = TEXT ( "landName" );
shString a3dTextFileTokens::a3dlandHeightPixelXString = TEXT ( "landHeightPixelX" );
shString a3dTextFileTokens::a3dlandHeightPixelYString = TEXT ( "landHeightPixelY" );
shString a3dTextFileTokens::a3da3dRailSystemString = TEXT ( "a3dRailSystem" );

shString a3dTextFileTokens::a3dviewportcountString = TEXT( "viewportcount" );
shString a3dTextFileTokens::a3drendercountString = TEXT( "rendercount" );
shString a3dTextFileTokens::a3ddropsizeString = TEXT( "dropsize" );
shString a3dTextFileTokens::a3dspeedString = TEXT( "speed" );
shString a3dTextFileTokens::a3dlifetimeString = TEXT( "lifetime" );
shString a3dTextFileTokens::a3dbirthrateString = TEXT( "birthrate" );
shString a3dTextFileTokens::a3demitterheightString = TEXT( "emitterheight" );
shString a3dTextFileTokens::a3demitterwidthString = TEXT( "emitterwidth" );

shString a3dTextFileTokens::a3dmodelDirectoryString = TEXT( "modelDirectory" );
shString a3dTextFileTokens::a3dtextureDirectoryString = TEXT( "textureDirectory" );
shString a3dTextFileTokens::a3deffectDirectoryString = TEXT( "effectDirectory" );
shString a3dTextFileTokens::a3dlandscapeDirectoryString = TEXT( "landscapeDirectory" );
shString a3dTextFileTokens::a3dparticleDirectoryString = TEXT( "particleDirectory" );
shString a3dTextFileTokens::a3drailDirectoryString = TEXT( "railDirectory" );
shString a3dTextFileTokens::a3dfontDirectoryString = TEXT( "fontDirectory" );
shString a3dTextFileTokens::a3dSprayString = TEXT( "Spray" );
shString a3dTextFileTokens::a3dLandString = TEXT( "a3dLand" );
shString a3dTextFileTokens::a3dOmniLightString = TEXT( "a3dOmniLight" );
shString a3dTextFileTokens::a3dDirectionalLightString = TEXT( "a3dDirectionalLight" );

bool isString( std::list< scriptLexeme* >::iterator &li ) { 

	return (*li)->type == LT_STRING;
}

bool importStringList( std::list< scriptLexeme* > &lexList, std::list< scriptLexeme* >::iterator &li, int count, shString *strings ) { 

	for( int i = 0; i < count; i++ ) { 
		if( !isString( li ) ) return false;
		strings[ i ] = (*li)->name;

		if( i == count - 1 ) break;
		if( !safeNextLex( lexList, li ) ) return false;
	}

	return true;
}

bool importBooleanList( std::list< scriptLexeme* > &lexList, std::list< scriptLexeme* >::iterator &li, int count, bool *values ) {

	for( int i = 0; i < count; i++ ) { 
		if( !readBoolValue( li, &values[ i ] ) ) return false;

		if( i == count - 1 ) break;
		if( !safeNextLex( lexList, li ) ) return false;
	}

	return true;
}

bool importIntList( std::list< scriptLexeme* > &lexList, std::list< scriptLexeme* >::iterator &li, int count, int *values  ) {

	for( int i = 0; i < count; i++ ) { 
		if( !(*li)->isNumericConst() ) return false;
		values[ i ] = (*li)->longValue;

		if( i == count - 1 ) break;
		if( !safeNextLex( lexList, li ) ) return false;
	}

	return true;
}

bool importFloatList( std::list< scriptLexeme* > &lexList, std::list< scriptLexeme* >::iterator &li, int count, float *values ) { 

	for( int i = 0; i < count; i++ ) { 
		if( !readFloatValue( lexList, li, &values[ i ] ) ) return false;

		if( i == count - 1 ) break;
		if( !safeNextLex( lexList, li ) ) return false;
	}

	return true;
}

bool	isBooleanClass( std::list< scriptLexeme* >::iterator &li ) {
	return isToken( li, a3dTextFileTokens::a3dBooleanClassString );
}

bool    isFloatClass( std::list< scriptLexeme* >::iterator &li ) { 
	return isToken( li, a3dTextFileTokens::a3dFloatString );
}

bool	isIntegerClass( std::list< scriptLexeme* >::iterator &li ) { 
	return isToken( li, a3dTextFileTokens::a3dIntegerString );
}

bool	isStringClass( std::list< scriptLexeme* >::iterator &li ) { 
	return isToken( li, a3dTextFileTokens::a3dStringString );
}

bool    isColorClass( std::list< scriptLexeme* >::iterator &li ) { 
	return isToken( li, a3dTextFileTokens::a3dColorString );
}

bool	isBitMapClass( std::list< scriptLexeme* >::iterator &li ) { 
	return isToken( li, a3dTextFileTokens::a3dBitMapString );
}

bool	isStandardMaterialClass( std::list< scriptLexeme* >::iterator &li ) { 
	return isToken( li, a3dTextFileTokens::a3dStandardMaterialString );
} 

bool	isToken( std::list< scriptLexeme* >::iterator &li, shString &tokenName ) { return (*li)->isId( tokenName ); }

void findNextToken( std::list< scriptLexeme* > &lexList, std::list< scriptLexeme* >::iterator &li, shString &tokenName ) { 

	for( ; li != lexList.end(); li ++ ) { 
		if( (*li)->isId( tokenName ) ) return ;
	}
	return ;
}

bool importFace(  std::list< scriptLexeme* > &lexList, std::list< scriptLexeme* >::iterator &li, a3dFace &face ) {

	if( !readParser( li, LPT_LEFT_SQUARE_BRACKET ) ) return false;

	if( !safeNextLex( lexList, li ) ) return false;	
	if( !readIntValue( lexList, li, &face.aIndex ) ) return false;

	if( !safeNextLex( lexList, li ) ) return false;
	if( !readParser( li, LPT_COMMA ) ) return false;

	if( !safeNextLex( lexList, li ) ) return false;
	if( !readIntValue( lexList, li, &face.bIndex ) ) return false;

	if( !safeNextLex( lexList, li ) ) return false;
	if( !readParser( li, LPT_COMMA ) ) return false;

	if( !safeNextLex( lexList, li ) ) return false;
	if( !readIntValue( lexList, li, &face.cIndex ) ) return false;

	if( !safeNextLex( lexList, li ) ) return false;	
	if( !readParser( li, LPT_RIGHT_SQUARE_BRACKET ) ) return false;

	// in max index starts from 1
	face.aIndex --;
	face.bIndex --;
	face.cIndex --;

	return true;
}

bool readFloatValue( std::list< scriptLexeme* > &lexList, std::list< scriptLexeme* >::iterator &li, float *floatVal ) { 

	float val = 1.0f;
	if( readParser( li, LPT_SUBTRACTION ) ) { 
		val = -1.0f;
		if( !safeNextLex( lexList, li ) ) return false;
	}

	if( (*li)->type != LT_CONST ) return false;
	if( (*li)->isNumericConst() ) *floatVal = (float)(*li)->longValue;
	else if( (*li)->constType == LCT_FLOAT ) *floatVal = (*li)->floatValue;
	else if( (*li)->constType == LCT_DOUBLE ) *floatVal = (float)(*li)->doubleValue;
	// учитываем знак
	*floatVal *= val;

	return true;
}

bool readIntValue( std::list< scriptLexeme* > &lexList, std::list< scriptLexeme* >::iterator &li, int *intVal ) { 

	int val = 1;
	if( readParser( li, LPT_SUBTRACTION ) ) { 
		val = -1;
		if( !safeNextLex( lexList, li ) ) return false;
	}

	if( !(*li)->isNumericConst() ) return false;
	*intVal = (*li)->longValue;

	*intVal *= val;

	return true;
}

bool readBoolValue( std::list< scriptLexeme* >::iterator &li, bool *boolVal ) { 

	if( isToken( li, a3dTextFileTokens::a3dTrueString ) ) *boolVal = true;
	else if( isToken( li, a3dTextFileTokens::a3dFalseString ) ) *boolVal = false;
	else return false;

	return true;
}

bool readParser( std::list< scriptLexeme* >::iterator &li, lexParserType pars ) { 

	if( (*li)->type != LT_PARSER || (*li)->parser != pars ) return false;

	return true;
}

bool importVertex( std::list< scriptLexeme* > &lexList, std::list< scriptLexeme* >::iterator &li, Vector3 v ) {

	if( !readParser( li, LPT_LEFT_SQUARE_BRACKET ) ) return false;

	if( !safeNextLex( lexList, li ) ) return false;	
	if( !readFloatValue( lexList, li, &(v[0]) ) ) return false;

	if( !safeNextLex( lexList, li ) ) return false;
	if( !readParser( li, LPT_COMMA ) ) return false;

	if( !safeNextLex( lexList, li ) ) return false;
	if( !readFloatValue( lexList, li, &(v[1]) ) ) return false;

	if( !safeNextLex( lexList, li ) ) return false;
	if( !readParser( li, LPT_COMMA ) ) return false;

	if( !safeNextLex( lexList, li ) ) return false;
	if( !readFloatValue( lexList, li, &(v[2]) ) ) return false;

	if( !safeNextLex( lexList, li ) ) return false;	
	if( !readParser( li, LPT_RIGHT_SQUARE_BRACKET ) ) return false;

	return true;
}

bool isTokenEnd( std::list< scriptLexeme* > &lexList, std::list< scriptLexeme* >::iterator &li, shString tokenName ) { 

	if( !(*li)->isId( a3dTextFileTokens::a3dEndString ) ) return false;

	if( !safeNextLex( lexList, li ) ) return false;
	if( !(*li)->isId( tokenName ) ) return false;

	return true;
}

bool isEnd( std::list< scriptLexeme* > &lexList, std::list< scriptLexeme* >::iterator &li ) { 
	return li == lexList.end();
}

bool safeNextLex( std::list< scriptLexeme* > &lexList, std::list< scriptLexeme* >::iterator &li ) { 

	li ++;
	std::list< scriptLexeme* >::iterator end = lexList.end();
	if( li == lexList.end() ) return false;

	return true;
}

bool readParamAssignment( std::list< scriptLexeme* > &lexList, std::list< scriptLexeme* >::iterator &li, shString &valName ) { 

	if( !(*li)->isId( valName ) ) return false;

	if( !safeNextLex( lexList, li ) ) return false;
	if( !readParser( li, LPT_ASSIGNMENT ) ) return false;

	return true;
}

bool readBoolParam( std::list< scriptLexeme* > &lexList, std::list< scriptLexeme* >::iterator &li, shString &valName, bool *boolVal ) { 

	if( !readParamAssignment( lexList, li, valName ) ) return false;
	if( !safeNextLex( lexList, li ) ) return false;
	if( !readBoolValue( li, boolVal ) ) return false;

	return true;
}

bool readFloatParam( std::list< scriptLexeme* > &lexList, std::list< scriptLexeme* >::iterator &li, shString &valName, float *floatVal ) { 

	if( !readParamAssignment( lexList, li, valName ) ) return false;

	if( !safeNextLex( lexList, li ) ) return false;
	if( !readFloatValue( lexList, li, floatVal ) ) return false;

	return true;
}

bool readIntParam( std::list< scriptLexeme* > &lexList, std::list< scriptLexeme* >::iterator &li, shString &valName, int *intVal ) { 

	if( !readParamAssignment( lexList, li, valName ) ) return false;

	if( !safeNextLex( lexList, li ) ) return false;
	if( !(*li)->isNumericConst() ) return false;

	*intVal = (*li)->longValue;

	return true;
}

bool readMatrixParam( std::list< scriptLexeme* > &lexList, std::list< scriptLexeme* >::iterator &li, shString &valName, Matrix4 mat ) { 

	Vector3 v;
	originMatrix4( mat );

	if( !readParamAssignment( lexList, li, valName ) ) return false;
	if( !safeNextLex( lexList, li ) ) return false;

	if( !readParser( li, LPT_LEFT_BRACKET ) ) return false;
	if( !safeNextLex( lexList, li ) ) return false;

	if( !(*li)->isId( a3dTextFileTokens::a3dMatrix3String ) ) return false;
	if( !safeNextLex( lexList, li ) ) return false;

	if( !importVertex( lexList, li, v ) ) return false;
	mat[0][0] = v[0]; mat[0][1] = v[1]; mat[0][2] = v[2];

	if( !safeNextLex( lexList, li ) ) return false;
	if( !importVertex( lexList, li, v ) ) return false;
	mat[1][0] = v[0]; mat[1][1] = v[1]; mat[1][2] = v[2];

	if( !safeNextLex( lexList, li ) ) return false;
	if( !importVertex( lexList, li, v ) ) return false;
	mat[2][0] = v[0]; mat[2][1] = v[1]; mat[2][2] = v[2];

	if( !safeNextLex( lexList, li ) ) return false;
	if( !importVertex( lexList, li, v ) ) return false;
	mat[3][0] = v[0]; mat[3][1] = v[1]; mat[3][2] = v[2];

	if( !safeNextLex( lexList, li ) ) return false;
	if( !readParser( li, LPT_RIGHT_BRACKET ) ) return false;

	return true;
}

bool readVertexParam( std::list< scriptLexeme* > &lexList, std::list< scriptLexeme* >::iterator &li, shString &valName, Vector3 v ) { 

	if( !readParamAssignment( lexList, li, valName ) ) return false;

	if( !safeNextLex( lexList, li ) ) return false;
	if( !importVertex( lexList, li, v ) ) return false;

	return true;
}

bool readColorValue( std::list< scriptLexeme* > &lexList, std::list< scriptLexeme* >::iterator &li, Vector4 v ) { 

	if( !readParser( li, LPT_LEFT_BRACKET ) ) return false;
	if( !safeNextLex( lexList, li ) ) return false;

	if( !(*li)->isId( a3dTextFileTokens::a3dcolorString ) ) return false;
	if( !safeNextLex( lexList, li ) ) return false;

	if( !readFloatValue( lexList, li, &(v[0])) ) return false;

	if( !safeNextLex( lexList, li ) ) return false;
	if( !readFloatValue( lexList, li, &(v[1])) ) return false;

	if( !safeNextLex( lexList, li ) ) return false;
	if( !readFloatValue( lexList, li, &(v[2])) ) return false;

	if( !safeNextLex( lexList, li ) ) return false;

	scaleVector3( v, 1.0f / 255.0f );
	if( readParser( li, LPT_RIGHT_BRACKET ) ) return true;

	if( !readFloatValue( lexList, li, &(v[3])) ) return false;

	if( !safeNextLex( lexList, li ) ) return false;
	if( !readParser( li, LPT_RIGHT_BRACKET ) ) return false;
	v[3] *= 1.0f / 255.0f; // if 4d color

	return true;
}

bool readColorParam( std::list< scriptLexeme* > &lexList, std::list< scriptLexeme* >::iterator &li, shString &valName, Vector4 v ) { 

	if( !readParamAssignment( lexList, li, valName ) ) return false;
	if( !safeNextLex( lexList, li ) ) return false;
	if( !readColorValue( lexList, li, v ) ) return false;	

	return true;
}

bool readQuaternionParam( std::list< scriptLexeme* > &lexList, std::list< scriptLexeme* >::iterator &li, shString &valName, Vector4 v ) { 

	if( !readParamAssignment( lexList, li, valName ) ) return false;
	if( !safeNextLex( lexList, li ) ) return false;

	if( !readParser( li, LPT_LEFT_BRACKET ) ) return false;
	if( !safeNextLex( lexList, li ) ) return false;

	if( !(*li)->isId( a3dTextFileTokens::a3dQuatString ) ) return false;
	if( !safeNextLex( lexList, li ) ) return false;

	if( !readFloatValue( lexList, li, &(v[0])) ) return false;

	if( !safeNextLex( lexList, li ) ) return false;
	if( !readFloatValue( lexList, li, &(v[1])) ) return false;

	if( !safeNextLex( lexList, li ) ) return false;
	if( !readFloatValue( lexList, li, &(v[2])) ) return false;

	if( !safeNextLex( lexList, li ) ) return false;
	if( !readFloatValue( lexList, li, &(v[3])) ) return false;

	if( !safeNextLex( lexList, li ) ) return false;
	if( !readParser( li, LPT_RIGHT_BRACKET ) ) return false;

	return true;
}

bool readStringValue( std::list< scriptLexeme* >::iterator &li, shString &val ) {

	if( (*li)->type != LT_STRING ) return false;
	val = (*li)->name;
	val.cutSpacesFromTheEnds();

	return true;
}

bool readStringParam( std::list< scriptLexeme* > &lexList, std::list< scriptLexeme* >::iterator &li, shString &valName, shString &stringVal ) { 

	if( !readParamAssignment( lexList, li, valName ) ) return false;
	if( !safeNextLex( lexList, li ) ) return false;

	if( !readStringValue( li, stringVal ) ) return false; 

	return true;
}


bool isTokenClass( std::list< scriptLexeme* >::iterator &li ) { 

	return (*li)->type == LT_ID;
}

bool findNextParserUntilParser( std::list< scriptLexeme* > &lexList, std::list< scriptLexeme* >::iterator &li, lexParserType findParser, lexParserType endParser ) { 
	
	while( li != lexList.end() ) { 
		if( (*li)->type != LT_PARSER ) { 
			li++;
			continue;
		}
		if( (*li)->parser == findParser ) return true;
		if( (*li)->parser == endParser ) return false;
		
		li++;
	}
	
	return false;
}

bool findNextConstantUntilParser( std::list< scriptLexeme* > &lexList, std::list< scriptLexeme* >::iterator &li, lexParserType endParser ) { 
	
	while( li != lexList.end() ) { 
		if( (*li)->type != LT_CONST && (*li)->type != LT_PARSER ) {
			li++;
			continue;
		}
		
		if( (*li)->type == LT_CONST ) return true;
		if( (*li)->parser == endParser ) return false;

		li++;
	}

	return false;

}

bool findNextParserUntilParser( std::list< scriptLexeme* > &lexList, std::list< scriptLexeme* >::iterator &li, lexParserType findParser, lexParserType endParser, lexParserType endParser2 ) { 

	while( li != lexList.end() ) { 
		if( (*li)->type != LT_PARSER ) { 
			li++;
			continue;
		}
		if( (*li)->parser == findParser ) return true;
		if( (*li)->parser == endParser ) return false;
		if( (*li)->parser == endParser2 ) return false;

		li++;
	}

	return false;
}